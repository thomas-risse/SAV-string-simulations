<jittershader name="Super string">
    <description>Traces a nice string </description>
    <param name="position" type="vec3" state="POSITION" />
    <param name="modelViewProjectionMatrix" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
    <param name="color" type="vec4" state="COLOR" />
	<param name="offsetz" type="float" state="OFFSETZ" />
    <param name="tex0" type="sampler2D" state="TEXTURE0"/>
    
    <language name="glsl" version="1.5">
        <bind param="position" program="vp" />
        <bind param="modelViewProjectionMatrix" program="vp" />
        <bind param="color" program="vp" />
        <bind param="tex0" program="fp" />

		<bind param="offsetz" program="vp" />

        <program name="vp" type="vertex">
<![CDATA[
#version 330 core
uniform mat4 modelViewProjectionMatrix;
in vec3 position;
in vec4 color;

out vec4 vColor;

uniform float offsetz;

void main() {
    gl_Position =  (vec4(position, 1.0) + vec4(0, 0, offsetz, 0)) ;
    vColor = color;
}
]]>
        </program>
        <program name="gp" type="geometry">
<![CDATA[
#version 330 core

layout(lines) in;
layout(triangle_strip, max_vertices = 32) out;

in vec4 vColor[];
out vec4 gColor;
out vec2 gTexCoord;

uniform mat4 modelViewProjectionMatrix;

// Number of sides for the tube
const int SIDES = 8;
const float RADIUS = 0.02; // Adjust for tube thickness

// Helper to compute a vector perpendicular to v
vec3 perpendicular(vec3 v) {
    if (abs(v.x) < abs(v.y)) {
        return normalize(vec3(0, -v.z, v.y));
    } else {
        return normalize(vec3(-v.z, 0, v.x));
    }
}

void main() {
    vec3 p0 = gl_in[0].gl_Position.xyz;
    vec3 p1 = gl_in[1].gl_Position.xyz;
    vec3 dir = normalize(p1 - p0);
    vec3 up = perpendicular(dir);
    vec3 right = normalize(cross(dir, up));
    up = cross(right, dir);

    for (int i = 0; i <= SIDES; ++i) {
        float theta = 2.0 * 3.1415926 * float(i) / float(SIDES);
        float c = cos(theta);
        float s = sin(theta);
        vec3 offset = RADIUS * (c * right + s * up);

        // Texture coordinates: u along the tube, v around the tube
        float v = float(i) / float(SIDES);

        // Start circle
        vec4 pos0 = vec4(p0 + offset, 1.0);
        gl_Position = modelViewProjectionMatrix * pos0;
        gColor = vColor[0];
        gTexCoord = vec2(0.0, v);
        EmitVertex();

        // End circle
        vec4 pos1 = vec4(p1 + offset, 1.0);
        gl_Position = modelViewProjectionMatrix * pos1;
        gColor = vColor[1];
        gTexCoord = vec2(1.0, v);
        EmitVertex();
    }
    EndPrimitive();
}
]]>
        </program>
        <program name="fp" type="fragment">
<![CDATA[
#version 330 core

in vec4 gColor;
in vec2 gTexCoord;
uniform sampler2D tex0;
out vec4 color;

void main() {
    vec4 texColor = texture(tex0, gTexCoord);
    // if (texColor.a == 0.0) { // crude check for missing texture
    //     texColor = vec4(1.0); // fallback to white
    // }
    color = gColor * texColor;
    // color = gColor; // Ignore texture for now
}
]]>
        </program>
    </language>
</jittershader>